#!/usr/bin/env python3
import os
import socket
import argparse
from tkinter.font import names
from urllib.parse import urlparse


# sends the command to the server with the proper syntax for ftp
def send_command(sock, command):
    print(f"Sending command: {command}")
    command = command + "\r\n"
    sock.sendall(command.encode())
    response = sock.recv(1024).decode()
    print(response)
    return response


# connects to the ftp server on port 21
def connect_to_ftp(user, pwd, port=21):

    # Regular socket connection with TCP
    socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    socks.connect(("ftp.4700.network", port))

    if not socks:
        print("not working here")

    response = socks.recv(1024).decode()
    print("Initial response:", response)

    if not response.startswith('220'):
        raise Exception("FTP not working")

    response_user = send_command(socks, f"USER {user}")
    print("USER response:", response_user)
    response_pass = send_command(socks, f"PASS {pwd}")
    print("PASS response:", response_pass)

    return socks


# ensure file type for transfer
def type_command(socks):
    response = send_command(socks, "TYPE I")
    return response


def mode_command(socks):
    response = send_command(socks, "MODE S")

    return response


def stru_command(socks):
    response = send_command(socks, "STRU F")

    return response


def pasv_command(socks):
    print("strtaing pasv command")
    response = send_command(socks, "PASV")
    print("PASV response:" +  response)

    type_response = type_command(socks)
    mode_response = mode_command(socks)
    stru_response = stru_command(socks)


    start_info = response.find("(") + 1
    end_info = response.find(")")
    number = response[start_info:end_info].split(",")
    print(number)
    ip = ".".join(number[0:4])
    print("data channel ip:" + ip)
    port = (int(number[4]) * 256) + int(number[5])
    data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    data_socket.connect((ip, port))


    return data_socket


def list_command(socks):
    data_socket = pasv_command(socks)
    response = send_command(socks, "LIST")

    # listen then execute and CLOSE DATA
    directory = []
    while chunk := data_socket.recv(1024).decode():
        directory.append(chunk)

    response_2 = ''.join(directory)

    data_socket.close()

    if data_socket.fileno() == -1:
        print("Data socket is successfully closed.")
    else:
        print("Data socket is still open.")

    print(response_2)

    return directory, response


# removes a file from the server
def dele_command(socks, filename):
    response = send_command(socks, f"DELE {filename}")


    print("deleted file:" + filename)


def mkd_command(socks, dir_name):
    response = send_command(socks, f"MKD {dir_name}")
    return response


def rmd_command(socks, dir_name):
    response = send_command(socks, f"RMD {dir_name}")
    return response


def stor_command(socks, file_name, data_socket):
    print(f"Beginning to store function with this file: {file_name}")


    response = send_command(socks, f"STOR {file_name}")

    if not os.path.exists(file_name):
        print(f"Error: {file_name} does not exist.")
        return  # Return early if the file is not found

    with open(file_name, "rb") as f:
        while chunk := f.read(1024):
            data_socket.send(chunk)
    data_socket.close()

    response = socks.recv(1024).decode()





    if data_socket.fileno() == -1:
        print("Data socket is successfully closed.")
    else:
        print("Data socket is still open.")



def retr_command(socks, file_source, file_dest):

    print("using the retr command")
    file_name_source = os.path.basename(file_source)

    file_name_dest = os.path.basename(file_dest)


     # Establish data connection for RETR
    print("director name of 2" + os.path.dirname(file_dest))
    print("director name of 1" + os.path.dirname(file_source))





    print("Copying this file:", file_name_source)

    data_socket = pasv_command(socks)

    response = send_command(socks, f"RETR {file_name_dest}")

    # downloading the file
    print("attempting to find file")
    with open(file_name_dest, 'wb') as file_download_to:
        print(f"file download to: {file_dest}")
        while True:
            chunk = data_socket.recv(1024)
            if not chunk:
                break
            file_download_to.write(chunk)

    data_socket.close()
    response = socks.recv(1024).decode()



    if "226" not in response:
        raise Exception(f"File transfer failed. Response: {response}")

    print(f"File {file_name_dest} downloaded successfully")


def quit_command(socks):
    response = send_command(socks, "QUIT")
    return response


def main():
    parser = argparse.ArgumentParser()
    sock = None
    name = ''

    parser.add_argument("operation", choices=["ls", "mkdir", "rm", "rmdir", "cp", "mv"],
                        help="FTP operation to perform")
    parser.add_argument("arguments", nargs="+")

    args = parser.parse_args()

    print("got to check command")
    if args.operation in ["ls", "mkdir", "rm", "rmdir"]:
        if len(args.arguments) < 1:
            print("Error: Missing argument for operation", args.operation)
            return

        parser_url = urlparse(args.arguments[0] if "://" in args.arguments[0] else "ftp://" + args.arguments[0])
        username = parser_url.username
        password = parser_url.password
        path = parser_url.path
        name = path.split('/')[-1]

        sock = connect_to_ftp(username, password)

    else:
        print("got to check command for 2 arguments")

        if args.arguments[0].startswith("ftp://"):
            parser_url = urlparse(args.arguments[0])
            username = parser_url.username
            password = parser_url.password
            sock = connect_to_ftp(username, password)
        elif args.arguments[1].startswith("ftp://"):
            parser_url = urlparse(args.arguments[1])
            username = parser_url.username
            password = parser_url.password
            print("got to connect to socket")
            sock = connect_to_ftp(username, password)


    # Handling different operations
    if not sock:
        print("Failed to connect to FTP server.")
        return
    if args.operation == "ls":
        list_command(sock)

    elif args.operation == "mkdir":
        print("Creating directory:", name)
        mkd_command(sock, name)

    elif args.operation == "rm":
        print("Removing file:", name)
        dele_command(sock, name)

    elif args.operation == "rmdir":
        print("Removing directory:", name)
        rmd_command(sock, name)

    elif args.operation == "cp":
        file_source = args.arguments[0]
        file_dest = args.arguments[1]
        print(f"Copying from {file_source} to {file_dest}")
        retr_command(sock, file_source, file_dest)

    elif args.operation == "mv":
        file_source = args.arguments[0]
        file_dest = args.arguments[1]

        # Generate a unique file name for the downloaded file
        file_download_to = os.path.basename(file_dest)
        print(f"Downloading file from {file_source} to temporary location {file_download_to}")

        retr_command(sock, file_source, file_download_to)

        print(f"Uploading file to {file_dest}")
        stor_command(sock, file_dest)

        print(f"Deleting original file {file_source}")
        dele_command(sock, file_source)

        os.remove(file_download_to)  # Remove temporary local copy

    sock.close()


if __name__ == '__main__':
    main()
