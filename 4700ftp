#!/usr/bin/env python3
import os
import socket
import argparse
from urllib.parse import urlparse


# sends the command to the server with the proper syntax for ftp
def send_command(sock, command):
    print(f"Sending command: {command}")
    command = command + "\r\n"
    sock.sendall(command.encode())
    response = sock.recv(1024).decode()
    print(response)
    return response


# connects to the ftp server on port 21
def connect_to_ftp(user, pwd, port=21):

    # Regular socket connection with TCP
    socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    socks.connect(("ftp.4700.network", port))

    response = socks.recv(1024).decode()
    print("Initial response:", response)

    if not response.startswith('220'):
        raise Exception("FTP not working")

    response_user = send_command(socks, f"USER {user}\r\n")
    print("USER response:", response_user)
    response_pass = send_command(socks, f"PASS {pwd}\r\n")
    print("PASS response:", response_pass)

    return socks


# ensure file type for transfer
def type_command(socks):
    response = send_command(socks, "TYPE I")
    return response


def mode_command(socks):
    response = send_command(socks, "MODE S")

    return response


def stru_command(socks):
    response = send_command(socks, "STRU F")

    return response


def pasv_command(socks):
    print("strtaing pasv command")
    response = send_command(socks, "PASV")
    print("PASV response:" +  response)

    type_response = type_command(socks)
    mode_response = mode_command(socks)
    stru_response = stru_command(socks)


    start_info = response.find("(") + 1
    end_info = response.find(")")
    number = response[start_info:end_info].split(",")
    print(number)
    ip = ".".join(number[0:4])
    print("data channel ip:" + ip)
    port = (int(number[4]) * 256) + int(number[5])
    data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    data_socket.connect((ip, port))


    return data_socket


def list_command(socks):
    data_socket = pasv_command(socks)
    response = send_command(socks, "LIST")

    # listen then execute and CLOSE DATA
    directory = []
    while chunk := data_socket.recv(1024).decode():
        directory.append(chunk)

    response_2 = ''.join(directory)

    data_socket.close()

    if data_socket.fileno() == -1:
        print("Data socket is successfully closed.")
    else:
        print("Data socket is still open.")

    print(response_2)

    return directory, response


# removes a file from the server
def dele_command(socks, filename):
    response = send_command(socks, f"DELE {filename}")


    print("deleted file:" + filename)


def mkd_command(socks, dir_name):
    response = send_command(socks, f"MKD {dir_name}")
    return response


def rmd_command(socks, dir_name):
    response = send_command(socks, f"RMD {dir_name}")
    return response


def stor_command(socks, file_name):
    data_socket = pasv_command(socks)
    print(f"Beginning to store function with this file: {file_name}")


    response = send_command(socks, f"STOR {file_name}")

    if not os.path.exists(file_name):
        print(f"Error: {file_name} does not exist.")
        return  # Return early if the file is not found

    with open(file_name, "rb") as f:
        while chunk := f.read(1024):
            data_socket.send(chunk)
    data_socket.close()

    response = socks.recv(1024).decode()

    if "226" in response:
        print("STOR transfer complete")
    else:
        print(f"Error during transfer: {response}")


    if data_socket.fileno() == -1:
        print("Data socket is successfully closed.")
    else:
        print("Data socket is still open.")



def retr_command(socks, file_source, file_dest):

    print("using the retr command")
    file_name_source = os.path.basename(file_source)

    file_name_dest = os.path.basename(file_dest)


     # Establish data connection for RETR
    print("director name of 2" + os.path.dirname(file_dest))
    print("director name of 1" + os.path.dirname(file_source))


    stor_command(socks, os.path.basename(file_dest))


    print("Copying this file:", file_name_source)

    data_socket = pasv_command(socks)
    response = send_command(socks, f"RETR {file_name_dest}")

    # downloading the file
    print("attempting to find file")
    with open(file_name_dest, 'wb') as file_download_to:
        print(f"file download to: {file_dest}")
        while True:
            chunk = data_socket.recv(1024)
            if not chunk:
                break
            file_download_to.write(chunk)

    data_socket.close()
    response = socks.recv(1024).decode()

    with open(file_name_dest, 'r') as file2:
        contents = file2.read()
        print("File contents of: " + file_name_dest + "\n", contents)

    with open(file_name_source, 'r') as file:
        contents = file.read()
        print("File contents of: " + file_name_source + "\n", contents)

    if "226" not in response:
        raise Exception(f"File transfer failed. Response: {response}")

    print(f"File {file_name_dest} downloaded successfully")


def quit_command(socks):
    response = send_command(socks, "QUIT")
    return response


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument("operation", choices=["ls", "mkdir", "rm", "rmdir", "cp", "mv"],
                        help="FTP operation to perform")

    parser.add_argument('arguments', nargs="+")

    args = parser.parse_args()


    parser_url = urlparse(args.arguments[0])
    username = parser_url.username
    print(f"Username: {username}")
    password = parser_url.password
    print(f"Password: {password}")
    print("URL is: " + parser_url.netloc + parser_url.path)
    sock = connect_to_ftp(username, password)
    path = parser_url.path
    name = path.split('/')[-1]

    if args.operation == "ls":
        list_command(sock)
    elif args.operation == "mkdir":
        if args.arguments:
            print("Directory:", name)
            mkd_command(sock, name)
        else:
            print("Provide name for directory")
    elif args.operation == "rm":
        if args.arguments:
            dele_command(sock, name)
        else:
            print("Provide name for file")
    elif args.operation == "rmdir":
        if args.arguments:
            rmd_command(sock, name)
        else:
            print("Provide name for directory")
    elif args.operation == "cp":
        if args.arguments:
            file_source = args.arguments[0]
            file_dest = args.arguments[1]
            if args.arguments[1].startswith("ftp"):
                parser_url = urlparse(args.arguments[1])
                username = parser_url.username
                password = parser_url.password
                sock = connect_to_ftp(username, password)
                print("File source:", file_source)
                print("File dest:", file_dest)
                retr_command(sock, file_source, file_dest)
            else:
                retr_command(sock, file_source, file_dest)
    elif args.operation == "mv":
        if len(args.arguments) == 2:
            file_source = args.arguments[0]
            file_dest = args.arguments[1]


            # Generate a unique file to store the downloaded file
            file_download_to = os.path.basename(file_dest)
            print(f"Temporary file created: {file_download_to}")

            # First, download the file from the source location (RETR)
            print(f"Retrieving file from source: {file_source}")
            retr_command(sock, file_source, file_download_to)

            # # Now, upload the file to the destination location (STOR)
            # print(f"Uploading file to destination: {file_dest}")
            # stor_command(sock, file_download_to)

            # Finally, delete the original source file (DELE)
            print(f"Deleting the source file: {file_source}")
            dele_command(sock, file_source)

            # Clean up: remove the temporary file after the operation
            os.remove(file_download_to)

    sock.close()


if __name__ == '__main__':
    main()
