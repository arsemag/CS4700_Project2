#!/usr/bin/env python3
import os
import socket
import argparse
from urllib.parse import urlparse


# sends the command to the server with the proper syntax for ftp
def send_command(sock, command):
    print(f"Sending command: {command}")
    sock.sendall(command.encode() + b"\r\n")
    response = sock.recv(1024).decode()

    if response.startswith('4') or response.startswith('5') or response.startswith('6'):
        print(response)

        quit_command(sock)

    return response


# connects to the ftp server on port 21
def connect_to_ftp(user, pwd, port=21):

    # Regular socket connection with TCP
    socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    socks.connect(("ftp.4700.network", port))

    if not socks:
        print("not working here")

    response = socks.recv(1024).decode()
    print("Initial response:", response)

    if not response.startswith('220'):
        raise Exception("FTP not working")

    response_user = send_command(socks, f"USER {user}")
    print("USER response:", response_user)
    response_pass = send_command(socks, f"PASS {pwd}")
    print("PASS response:", response_pass)



    return socks


# ensure file type for transfer
def type_command(socks):
    response = send_command(socks, "TYPE I")



    return response


def mode_command(socks):
    response = send_command(socks, "MODE S")



    return response


def stru_command(socks):
    response = send_command(socks, "STRU F")



    return response


def pasv_command(socks):
    type_response = type_command(socks)
    mode_response = mode_command(socks)
    stru_response = stru_command(socks)


    print("strtaing pasv command")
    response = send_command(socks, "PASV")



    if "227" not in response:
        print("PASV response did not work")

    start_info = response.find("(") + 1
    end_info = response.find(")")
    number = response[start_info:end_info].split(",")
    print(number)
    ip = ".".join(number[0:4])
    print("data channel ip:" + ip)
    port = (int(number[4]) * 256) + int(number[5])
    data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    data_socket.connect((ip, port))

    if response.startswith('4') or response.startswith('5') or response.startswith('6'):
        print(response)

        quit_command(socks)


    return data_socket


def list_command(socks):
    data_socket = pasv_command(socks)
    response = send_command(socks, "LIST")

    # listen then execute and CLOSE DATA
    directory = []
    while True:
        chunk = data_socket.recv(1024).decode()
        if not chunk:  # Check if the chunk is empty, meaning end of data
            break
        directory.append(chunk)

    response_2 = ''.join(directory)

    data_socket.close()

    print(response_2)
    return directory, response_2


# removes a file from the server
def dele_command(socks, filename):
    response = send_command(socks, f"DELE {filename}")


    print("deleted file:" + filename)
    return response


def mkd_command(socks, dir_name):
    print(dir_name)
    response = send_command(socks, f"MKD {dir_name}")

    return response


def rmd_command(socks, dir_name):
    response = send_command(socks, f"RMD {dir_name}")


    return response


def stor_command(socks, file_sor, file_dest):
    data_socket = pasv_command(socks)
    print("Copying file from using store: " + os.path.basename(file_sor) + "to: " + os.path.basename(file_dest))
    print(f"Beginning to store function with this file this is the source: {os.path.basename(file_sor)}")
    print(f"Beginning to store function with this file to be the destionation: {os.path.basename(file_dest)}")


    response = send_command(socks, f"STOR {os.path.basename(file_dest)}")




    print(f"Beginning to store function with this file: {file_dest}")
    with open(os.path.basename(file_sor), "rb") as f:
        while chunk := f.read(1024):
            data_socket.sendall(chunk)

    data_socket.close()

    response = socks.recv(1024).decode()






    print(response)




def retr_command(socks, file_source, file_dest):

    print("using the retr command")
    file_name_source = os.path.basename(file_source)

    file_name_dest = os.path.basename(file_dest)


     # Establish data connection for RETR
    print("director name of 2" + os.path.dirname(file_dest))
    print("director name of 1" + os.path.dirname(file_source))
    print("Copying this file:", file_name_source)

    data_socket = pasv_command(socks)
    response = send_command(socks, f"RETR {file_name_dest}")

    # downloading the file
    print("attempting to find file")
    with open(file_name_dest, 'wb') as file_download_to:
        print(f"file download to: {file_dest}")
        while True:
            chunk = data_socket.recv(1024)
            if not chunk:
                break
            file_download_to.write(chunk)

    data_socket.close()
    response = socks.recv(1024).decode()





def quit_command(socks):
    response = send_command(socks, "QUIT")
    return response


def main():
    parser = argparse.ArgumentParser()
    sock = None
    name = ''

    parser.add_argument("operation", choices=["ls", "mkdir", "rm", "rmdir", "cp", "mv"],
                        help="FTP operation to perform")
    parser.add_argument("arguments", nargs="+")

    args = parser.parse_args()

    print("got to check command")


    print(args)
    if args.arguments[0].startswith("ftp://"):
        parser_url = urlparse(args.arguments[0])
        username = parser_url.username
        password = parser_url.password
        name = parser_url.path
        sock = connect_to_ftp(username, password)

    elif args.arguments[1].startswith("ftp://"):
        parser_url = urlparse(args.arguments[1])
        username = parser_url.username
        password = parser_url.password
        name = parser_url.path
        print("got to connect to socket")
        sock = connect_to_ftp(username, password)


    # Handling different operations
    if not sock:
        print("Failed to connect to FTP server.")
        return
    if args.operation == "ls":
        list_command(sock)

    elif args.operation == "mkdir":
        print("this is the path", name)
        print("Creating directory:", name)
        mkd_command(sock, name)

    elif args.operation == "rm":
        print("Removing file:", name)
        dele_command(sock, name)

    elif args.operation == "rmdir":
        print("Removing directory:", name)
        rmd_command(sock, name)

    elif args.operation == "cp":
        file_source = args.arguments[0]  # has the lpcal
        file_dest = args.arguments[1]

        if file_source.startswith("ftp://"):
            parser_url = urlparse(file_source)
            file_source = parser_url.path
            print(file_source)# has the server
            print("this is the path")
            print("Copying file from using retreve: " + file_source + "to: " + file_dest)
            retr_command(sock, file_source, file_dest)
        else:
            if file_dest.startswith("ftp://"):
                parser_url = urlparse(file_dest)
                file_dest = parser_url.path
                print("Copying file from using store: " + file_source + "to: " + file_dest)
                stor_command(sock, file_source, file_dest)

    elif args.operation == "mv":
        file_source = args.arguments[0] # would have local if not in if not statments
        file_destination = args.arguments[1]

        if file_source.startswith("ftp://"):
            parser_url = urlparse(file_source)
            file_source = parser_url.path            # has the server
            print("this is the path")
            ## O has the the server information
            print(f"Downloading file from the server with this file {file_source} to temporary "
                  f"location on local path{file_destination}")
            retr_command(sock, file_source, file_destination)
            print(f"Deleting original file {file_source}")
            dele_command(sock, file_source)

        else:
            if file_destination.startswith("ftp://"):
                parser_url = file_destination(args.arguments[1])
                file_dest = parser_url.path
            print("Downloading file from: the local" + file_source + "to: on the server " + file_destination)
            stor_command(sock, file_source, file_destination)


    sock.close()


if __name__ == '__main__':
    main()
