#!/usr/bin/env python3
import os
import socket
import argparse
import tempfile
from http.client import responses
from urllib.parse import urlparse


# sends the command to the server with the proper syntax for ftp
def send_command(sock, command):
    print("Sending command: {}".format(command))
    command = command + "\r\n"
    sock.sendall(command.encode())
    response = sock.recv(1024).decode()
    print(response)
    return response


# connects to the ftp server on port 21
def connect_to_ftp(port=21):
    username = "gebreyesus.a"
    password = "a1dafa328c068c9125c1ef321d4824d25ca07484fce69d7c53ad86a8d3147ba2"
    # Regular socket connection with TCP
    socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    socks.connect(("ftp.4700.network", port))

    response = socks.recv(1024).decode()
    print("Initial response:", response)

    if not response.startswith('220'):
        raise Exception("FTP not working")

    response_user = send_command(socks, f"USER {username}\r\n")
    print("USER response:", response_user)
    response_pass = send_command(socks, f"PASS {password}\r\n")
    print("PASS response:", response_pass)



    return socks


# ensure file type for transfer
def type_command(socks):
    response = send_command(socks, "TYPE I")

    return response



def mode_command(socks):
     response = send_command(socks, "MODE S")
     if "200" not in response and "215" not in response:
         raise Exception("Type error")

     return response

def stru_command(socks):
    response = send_command(socks, "STRU F")
    if "200" not in response:
        raise Exception("Type error")
    else:
        return response

## will open the data channel
def pasv_command(socks):
    response = send_command(socks, "PASV")
    return response



def connect_to_data_channel(socks):
    type_response = type_command(socks)
    mode_response = mode_command(socks)
    stru_response = stru_command(socks)
    response = pasv_command(socks)

    start_info = response.find("(") + 1
    end_info = response.find(")")
    number = response[start_info:end_info].split(",")
    ip = ".".join(number[0:4])
    print("data channel ip:" + ip)
    port = (int(number[4]) * 256) + int(number[5])
    print("data channel port:" + str(port))
    data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    data_socket.connect((ip, port))

    return data_socket



def list_command(socks, data_socket):
    response = send_command(socks, "LIST")

   ## listen then execute and CLOSE DATA

    directory = []
    while chunk := data_socket.recv(1024).decode():
        directory.append(chunk)

    response_2 = ''.join(directory)


    data_socket.close()

    print(response_2)
    return directory


# removes a file from the server
def dele_command(socks, filename):

    response = send_command(socks, f"DELE {filename}")
    if "250" not in response:
        raise Exception("Delete did not work")

    print("deleted file:" + filename)


def mkd_command(socks, dir_name):


    response = send_command(socks, f"MKD {dir_name}")

    return response



def rmd_command(socks, dir_name):
     response = send_command(socks, f"RMD {dir_name}")
     return response


def stor_command(socks, file_path, data_socket):
    print("Beginning to store funtion with this file: {}".format(file_path))
    pasv_response = pasv_command(socks)

    response = send_command(socks, f"STOR {file_path}")


    print("trying to open file and this is file: {}".format(file_path))



    response = socks.recv(1024).decode()

    data_socket.close()


    print("STOR transfer complete")


def retr_command(socks, file_machine, file_to_download_on_server, data_socket):
    print("using the retr command")
    file_name_on_machine = os.path.basename(file_machine)

    file_to_download_on_server = os.path.basename(file_to_download_on_server)
    print("file download to:" + file_machine)
    print("file getting from " + file_to_download_on_server)


    pasv_response = pasv_command(socks)
    response = send_command(socks, f"RETR {file_to_download_on_server}")


    # downloading the file
    with open(file_machine, 'wb') as file_download_to:
        while True:
            chunk = data_socket.recv(1024)
            if not chunk:
                break
            file_download_to.write(chunk)


    data_socket.close()
    response = socks.recv(1024).decode()

    if "226" not in response:
        raise Exception(f"File transfer failed. Response: {response}")

    print(f"File {file_download_to} downloaded successfully")



def quit_command(socks):
     response = send_command(socks, "QUIT")

     return response


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("operation", choices=["ls", "mkdir", "rm", "rmdir", "cp", "mv"],
                        help="FTP operation to perform")

    parser.add_argument('arguments', nargs="+")

    args = parser.parse_args()
    sock = connect_to_ftp()
    data_socket = connect_to_data_channel(sock)

    parser_url = urlparse(args.arguments[0])
    print("URL is: " + parser_url.netloc + parser_url.path)

    path = parser_url.path
    name = path.split('/')[-1]



    if args.operation == "ls":
        list_command(sock, data_socket)
    elif args.operation == "mkdir":
        if args.arguments:
            print("Directory:", name)
            mkd_command(sock, name)
        else:
            print("Provide name for directory")
    elif args.operation == "rm":
        if args.arguments:
            dele_command(sock, name)
        else:
            print("Provide name for file")
    elif args.operation == "rmdir":
        if args.arguments:
            rmd_command(sock, name)
        else:
            print("Provide name for directory")
    elif args.operation == "cp":
        if args.arguments:
            file_my_machine = args.arguments[0]
            file_to_down = args.arguments[1]

            print("Checking if file exists before copying...")
            directory = list_command(sock, data_socket)  # Retrieve directory listing
            print(directory)
            if file_to_down not in ''.join(directory):
                stor_command(sock, os.path.basename(file_to_down), data_socket)
                print(f"Error: File '{file_to_down}' not found in directory.")
                sock.close()
                return

            print("Copying this file:", file_to_down)


            retr_command(sock, file_my_machine, file_to_down, data_socket)
        else:
            print("Provide name for file")
    elif args.operation == "mv":
        if len(args.arguments) == 2:
            source = args.arguments[0]
            destination = args.arguments[1]

            # Generate a unique temporary file to store the downloaded file
            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                file_download_to = temp_file.name  # Get the temp file name
                print(f"Temporary file created: {file_download_to}")

            # First, download the file from the source location (RETR)
            print(f"Retrieving file from source: {source}")
            retr_command(sock, source, file_download_to, data_socket)


            # Now, upload the file to the destination location (STOR)
            print(f"Uploading file to destination: {destination}")
            stor_command(sock, file_download_to, data_socket)

            # Finally, delete the original source file (DELE)
            print(f"Deleting the source file: {source}")
            dele_command(sock, source)

            # Clean up: remove the temporary file after the operation
            os.remove(file_download_to)

    sock.close()


if __name__ == '__main__':
    main()